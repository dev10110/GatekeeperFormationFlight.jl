var documenterSearchIndex = {"docs":
[{"location":"tracking_controllers/#Tracking-Controller","page":"Tracking Controllers","title":"Tracking Controller","text":"","category":"section"},{"location":"tracking_controllers/#Tutorial","page":"Tracking Controllers","title":"Tutorial","text":"","category":"section"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"Given a dubins path, we can now run a simulation of tracking it. ","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"Given a path::Vector{DubinsPath}, we have the following methods:","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"x_d, u_d = get_reference_state_and_input(path, time) which returns state and input to track the trajectory at some time\nx_d, u_d = get_reference_state_and_input(path, time, offset) which returns the same, but for an offset path. the offset is specified as offset = (d, n) where d is the tangential offset, and n is the offset in the normal direction. \nu = tracking_controller(x, x_d, u_d) which returns the control input to track a trajectory with a given desired state x_d and a feedforward control input u_d. ","category":"page"},{"location":"tracking_controllers/#Example","page":"Tracking Controllers","title":"Example","text":"","category":"section"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"Consider the same environment as in the RRT* page.","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"using GatekeeperFormationFlight\nusing Plots, LinearAlgebra, StaticArrays, Random\nusing Dubins\n\nGFF = GatekeeperFormationFlight\n\n# create an environment\nfunction create_random_scenario(N_wezes=24)\n    wezes_1 = [Cardioid(rand(), rand()) for i=1:N_wezes/2]\n    wezes_2 = [Cardioid(0.5 + 0.2 * randn(), 0.5 + 0.2 * randn()) for i=1:N_wezes/2]\n    wezes = vcat(wezes_1, wezes_2)\n    return wezes\nend\nRandom.seed!(27182818)\nwezes = create_random_scenario(24)\n\n# create a set of robots\nleader_robot = Robot(-0.25,0.,0.)\nfollower_robots = [\n    Robot(-0.3, -0.05, 0.0), \n    Robot(-0.3, 0.05, 0.0), \n    ]\nrobots = vcat(leader_robot, follower_robots...)\n\n# plan a path for the leader using RRT*\ndomain = (\n    (@SVector [0, 0, -1.0*π]),\n    (@SVector [1, 1,  1.0*π])\n)\nturning_radius = 0.1\nrrt_problem = DubinsRRTProblem(domain, turning_radius, wezes)\n\n# start the tree with the root node\nnodes = [Node(SVector(0,0,0.)), ]\n\n# add 1000 nodes to the tree\nnodes = rrt_star(rrt_problem, nodes, 1000)\n\n# see if there is a path \nsuccess_code, waypoints = get_best_path(rrt_problem, nodes, @SVector [1.0, 1.0, 0])\n\n# uncomment the following code if you want to add more nodes to the RRT* problem:\n## while we havent found a path, add some nodes and check if we have a feasible path\n## iter_counter = 0\n## while !success_code  && iter_counter < 10\n##     nodes = rrt_star(rrt_problem, nodes, 500)\n##     success_code, waypoints = get_best_path(rrt_problem, nodes, [1.0, 1.0, 0])\n##     iter_counter += 1\n## end\n        \n@assert success_code\n\n# prepend and append the start and the goal\nwaypoints = [\n    SVector(leader_robot), \n    waypoints..., \n    SVector(1.25,1,0.)\n]\n\npath = DubinsPath[]\n# add all the waypoints to the path\nfor i=2:length(waypoints)\n    e, p = dubins_shortest_path(waypoints[i-1], waypoints[i], rrt_problem.turning_radius)\n    @assert e == Dubins.EDUBOK\n    push!(path, p)\nend\n\n# small function to help plot things\nfunction plot_scenario!(wezes::VW, robots::VR; draw_bbox=true, title=nothing, kwargs...) where {W <: GFF.AbstractWez, VW <: AbstractVector{W}, R <: Robot, VR <: AbstractVector{R}}\n\n    if draw_bbox\n        # plot the bounding box\n        plot!([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], label = false, color = :black)\n        plot!(xlims = (-0.4, 1.4), ylims = (-0.1, 1.1))\n    end\n\n    # plot the wezes\n    for wez in wezes, robot in robots\n        plot!(wez, robot)\n    end\n\n    # plot the robot\n    for robot in robots\n        color = is_colliding(wezes, robot) ? :red : :green\n        plot!(robot; color = color)\n    end\n\n    if isnothing(title)\n        # get the minimum collision distance\n        mind = Inf\n        for r in robots, w in wezes\n            d = collision_distance(w, r)\n            mind = min(mind, d)\n        end\n        plot!(title = \"Min Wez Distance: $(round(mind; digits=2))\")\n\n        if mind <= 0\n            plot!(titlefont = font(:red))\n        else\n            plot!(titlefont = font(:black))\n        end\n    else\n        plot!(title = title)\n    end\n\n    plot!()\n\nend\n\nplot()\nplot_scenario!(wezes, robots)\nplot!(path, color=:black, label=false, linewidth=2)\ntitle!(\"best path\")\nplot!()","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"plot!()","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"We can construct the offset paths as follows:","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"function offset_path_1(t)\n    offset = SVector(follower_robots[1]) - SVector(leader_robot)\n    x_d, u_d = get_reference_state_and_input(path, t, offset)\n    return x_d[SOneTo(2)]\nend\n\nfunction offset_path_2(t)\n    offset = SVector(follower_robots[2]) - SVector(leader_robot)\n    x_d, u_d = get_reference_state_and_input(path, t, offset)\n    return x_d[SOneTo(2)]\nend\n\n# get the total time span\ntspan = (0.0, total_path_length(path))\n\n# plot the paths\nplot!(t -> offset_path_1(t)[1], t -> offset_path_1(t)[2], tspan...; color=:gray, linestyle=:dash, label=false)\nplot!(t -> offset_path_2(t)[1], t -> offset_path_2(t)[2], tspan...; color=:gray, linestyle=:dash, label=false)","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"However these offset paths do not respect input bounds.  We can now simulate a robot tracking this trajectory:","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"using OrdinaryDiffEq\n\n# define the closed-loop controller\nfunction closed_loop_tracking(x, params, t)\n    \n    # extract params\n    ref_path, offset = params\n\n    # get the nominal tracking control input \n    x_d, u_d = get_reference_state_and_input(ref_path, t, offset)\n    u = tracking_controller(x, x_d, u_d)\n\n    # apply input bounds\n    v, ω = apply_input_bounds(u...)\n\n    # compute xdot\n    θ = x[3]\n    xdot = SVector(v * cos(θ), v * sin(θ), ω)\n\n    return xdot\nend\n\n# define the ODE problem\ntspan = (0, total_path_length(path))\nparams_1 = (path, SVector(follower_robots[1]) - SVector(leader_robot))\nparams_2 = (path, SVector(follower_robots[2]) - SVector(leader_robot))\n\nprob_1 = ODEProblem(closed_loop_tracking, SVector(follower_robots[1]), tspan, params_1)\nprob_2 = ODEProblem(closed_loop_tracking, SVector(follower_robots[2]), tspan, params_2)\n\n# solve the problems\nsol_1 = solve(prob_1)\nsol_2 = solve(prob_2)\n\n# plot the solution\nplot!(t -> sol_1(t)[1], t -> sol_1(t)[2], tspan..., color=:green, linewidth=2, label=false)\nplot!(t -> sol_2(t)[1], t -> sol_2(t)[2], tspan..., color=:green, linewidth=2, label=false)","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"We can animate the result too:","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"\n@gif for t in range(tspan..., length=120)\n\n    leader_state, _ = get_reference_state_and_input(path, t)\n    follower_1_state = sol_1(t)\n    follower_2_state = sol_2(t)\n\n    robots_ = Robot.([leader_state, follower_1_state, follower_2_state])\n\n    # plot the reference paths\n    plot()\n    plot!(t -> offset_path_1(t)[1], t -> offset_path_1(t)[2], tspan...; color=:gray, linestyle=:dash, label=false)\n    plot!(t -> offset_path_2(t)[1], t -> offset_path_2(t)[2], tspan...; color=:gray, linestyle=:dash, label=false)\n\n    # plot the robots at the current time\n    plot_scenario!(wezes, robots_)\n\nend","category":"page"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"This closed-loop tracking controller will be exported as part of the gatekeeper methods later.","category":"page"},{"location":"tracking_controllers/#Docs","page":"Tracking Controllers","title":"Docs","text":"","category":"section"},{"location":"tracking_controllers/#Public:","page":"Tracking Controllers","title":"Public:","text":"","category":"section"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"Modules = [GatekeeperFormationFlight]\nPages = [\"tracking_controller.jl\"]\nPrivate = false","category":"page"},{"location":"tracking_controllers/#GatekeeperFormationFlight.get_reference_state-Tuple{Vector{Dubins.DubinsPath}, Any, Any}-tracking_controllers","page":"Tracking Controllers","title":"GatekeeperFormationFlight.get_reference_state","text":"get_reference_state(path::Vector{DubinsPath}, time, offset)\n\nget the x_d to follow a path at some time, with a given offset.\n\n\n\n\n\n","category":"method"},{"location":"tracking_controllers/#GatekeeperFormationFlight.get_reference_state-Tuple{Vector{Dubins.DubinsPath}, Any}-tracking_controllers","page":"Tracking Controllers","title":"GatekeeperFormationFlight.get_reference_state","text":"get_reference_state(path::Vector{DubinsPath}, time)\n\nget the x_d to follow a path at some time.\n\n\n\n\n\n","category":"method"},{"location":"tracking_controllers/#GatekeeperFormationFlight.get_reference_state_and_input-Tuple{Any, Any, Any}-tracking_controllers","page":"Tracking Controllers","title":"GatekeeperFormationFlight.get_reference_state_and_input","text":"get_reference_state_and_input(path::Vector{DubinsPath}, time, offset)\n\nget the (x_d, u_d) to follow a path at some time, with a given offset.\n\n\n\n\n\n","category":"method"},{"location":"tracking_controllers/#GatekeeperFormationFlight.get_reference_state_and_input-Tuple{Vector{Dubins.DubinsPath}, Any}-tracking_controllers","page":"Tracking Controllers","title":"GatekeeperFormationFlight.get_reference_state_and_input","text":"get_reference_state_and_input(path::Vector{DubinsPath}, time)\n\nget the (x_d, u_d) to follow a path at some time\n\n\n\n\n\n","category":"method"},{"location":"tracking_controllers/#GatekeeperFormationFlight.tracking_controller-Tuple{Any, Any, Any}-tracking_controllers","page":"Tracking Controllers","title":"GatekeeperFormationFlight.tracking_controller","text":"tracking_controller(x, x_d, u_d; k1=450.0, k2=200.0, k3=50.0)\n\nreturns the [v, ω] to track a state x_d from current state x, given a feedforward term u_d. \n\n\n\n\n\n","category":"method"},{"location":"tracking_controllers/#Private:","page":"Tracking Controllers","title":"Private:","text":"","category":"section"},{"location":"tracking_controllers/","page":"Tracking Controllers","title":"Tracking Controllers","text":"Modules = [GatekeeperFormationFlight]\nPages = [\"tracking_controller.jl\"]\nPublic = false","category":"page"},{"location":"tracking_controllers/#GatekeeperFormationFlight.post_extrapolate-Tuple{Any, Any}-tracking_controllers","page":"Tracking Controllers","title":"GatekeeperFormationFlight.post_extrapolate","text":"post_extrapolate(path, time)\n\nreturn the state, input for a reference path beyond the end of the path, assumes the robot moves with v=1.0, ω=0.0.\n\n\n\n\n\n","category":"method"},{"location":"tracking_controllers/#GatekeeperFormationFlight.pre_extrapolate-Tuple{Vector{Dubins.DubinsPath}, Any}-tracking_controllers","page":"Tracking Controllers","title":"GatekeeperFormationFlight.pre_extrapolate","text":"pre_extrapolate(path, time)\n\nreturn the state, input for a reference path for negative time. Assumes the robot moves with v=1.0, ω=0.0.\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Gatekeeper-Formation-Flight","page":"API","title":"Gatekeeper Formation Flight","text":"","category":"section"},{"location":"api/#Public:","page":"API","title":"Public:","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GatekeeperFormationFlight]\nPrivate = false","category":"page"},{"location":"api/#GatekeeperFormationFlight.Cardioid","page":"API","title":"GatekeeperFormationFlight.Cardioid","text":"Cardioid(x, y, Rmin=0.0, Rmax=0.15)\n\nConstruct a Cardioid WEZ at position x, y with radii Rmin, and Rmax.\n\n\n\n\n\n","category":"type"},{"location":"api/#GatekeeperFormationFlight.Cbez","page":"API","title":"GatekeeperFormationFlight.Cbez","text":"Cbez(x, y, ψ)\nCbez(x, y, ψ, μ=0.9, ā=0.25, v=1.0, R=π/2, t=π/2)\n\nDefine a Curve-Only Basic WEZ at some x, y with a heading ψ. \n\n\n\n\n\n","category":"type"},{"location":"api/#GatekeeperFormationFlight.CircularWez","page":"API","title":"GatekeeperFormationFlight.CircularWez","text":"CircularWez(x, y, R=0.15)\n\nDefine a Circluar WEZ at some x, y with radius R.\n\n\n\n\n\n","category":"type"},{"location":"api/#GatekeeperFormationFlight.DubinsRRTProblem","page":"API","title":"GatekeeperFormationFlight.DubinsRRTProblem","text":"DubinsRRTProblem(domain, turning_radius, wezes)\n\nConstruct a dubins RRT* problem. \n\nParameters:\n\ndomain: a tuple defining the domain\nturning_radius: turning radius for Dubins paths\nwezes: A vector of wezes to avoid\n\nExample:\n\nusing GatekeeperFormationFlight\nusing StaticArrays\n\nmin_domain = SVector{3}(0.0, 0.0, -1.0*π)\nmax_domain = SVector{3}(1.0, 1.0, 1.0*π)\ndomain = (min_domain, max_domain)\n\nturning_radius = 0.1\n\nwezes = [Cardioid(rand(), rand()) for i=1:10]\n\nrrt_problem = DubinsRRTProblem(domain, turning_radius, wezes)\n\n\n\n\n\n","category":"type"},{"location":"api/#GatekeeperFormationFlight.GatekeeperProblem","page":"API","title":"GatekeeperFormationFlight.GatekeeperProblem","text":"GatekeeperProblem(kwargs...)\n\nconstruct a GatekeeperProblem. The arguments are:\n\nwezes,                              # list of wezes\nreference_path,                     # path of the leader\noffset = SVector(0.0, 0.0, 0.0),    # desired offset from the leaders path\nturning_radius = 0.1,               # max turning radius of a robot\nmaxTshorizon = 1.0,               # maximum switching time\nreconnectionstepsize = 0.1,       # resolution used for checking reconnection point\ncollisioncheckstep_size = 0.01,   # resolution used for checking collision along a path\nintegrationmaxstep_size = 0.05,   # max integration step size in nominal tracking\nswitchstepsize = 0.05             # resolution used to decrease switch time\n\n\n\n\n\n","category":"type"},{"location":"api/#GatekeeperFormationFlight.Robot","page":"API","title":"GatekeeperFormationFlight.Robot","text":"Robot(x, y, ψ)\nRobot([x, y, ψ])\n\nCreate a robot with some x, y position and heading ψ.\n\n\n\n\n\n","category":"type"},{"location":"api/#GatekeeperFormationFlight.apply_input_bounds-Tuple{Any, Any}","page":"API","title":"GatekeeperFormationFlight.apply_input_bounds","text":"apply_input_bounds(v, ω; v_min = 0.8, v_max = 1.0, R_min = 0.1)\n\napply input bounds to a v, ω.  Extracted as a function to make sure input bounds get applied everywhere uniformly.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.collision_distance","page":"API","title":"GatekeeperFormationFlight.collision_distance","text":"collision_distance(wez::AbstractWez, robot::Robot)\ncollision_distance(wezez::Vector{AbstractWez}, robot::Robot)\n\nreturns the distance to collision for this robot to the wez. Positive if safe. If the robot is within the wez, it will return a negative number. \n\n\n\n\n\n","category":"function"},{"location":"api/#GatekeeperFormationFlight.construct_candidate_trajectory-Tuple{Any, Any, GatekeeperProblem}","page":"API","title":"GatekeeperFormationFlight.construct_candidate_trajectory","text":"construct_candidate_trajectory(time, state, prob::GatekeeperProblem)\n\nconstructs a nominal trajectory, and working backwards tries to construct backup trajectories.  If a safe trajectory is found, this is returned as the candidate trajectory.  if not, nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.get_reference_state-Tuple{Vector{Dubins.DubinsPath}, Any, Any}","page":"API","title":"GatekeeperFormationFlight.get_reference_state","text":"get_reference_state(path::Vector{DubinsPath}, time, offset)\n\nget the x_d to follow a path at some time, with a given offset.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.get_reference_state-Tuple{Vector{Dubins.DubinsPath}, Any}","page":"API","title":"GatekeeperFormationFlight.get_reference_state","text":"get_reference_state(path::Vector{DubinsPath}, time)\n\nget the x_d to follow a path at some time.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.get_reference_state_and_input-Tuple{Any, Any, Any}","page":"API","title":"GatekeeperFormationFlight.get_reference_state_and_input","text":"get_reference_state_and_input(path::Vector{DubinsPath}, time, offset)\n\nget the (x_d, u_d) to follow a path at some time, with a given offset.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.get_reference_state_and_input-Tuple{Vector{Dubins.DubinsPath}, Any}","page":"API","title":"GatekeeperFormationFlight.get_reference_state_and_input","text":"get_reference_state_and_input(path::Vector{DubinsPath}, time)\n\nget the (x_d, u_d) to follow a path at some time\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.is_colliding","page":"API","title":"GatekeeperFormationFlight.is_colliding","text":"is_colliding(reg1::CollisionRegion, reg2::CollisionRegion, tol=0)\n\nreturn true if the distance between reg1 and reg2 is less than tol.\n\n\n\n\n\n","category":"function"},{"location":"api/#GatekeeperFormationFlight.is_colliding-2","page":"API","title":"GatekeeperFormationFlight.is_colliding","text":"is_colliding(wez::AbstractWez, robot::Robot, tol)\nis_colliding(wezes::Vector{AbstractWez}, robot::Robot, tol)\n\nreturns collision_distance(wez, robot) <= tol\n\n\n\n\n\n","category":"function"},{"location":"api/#GatekeeperFormationFlight.is_colliding-Union{Tuple{VW}, Tuple{W}, Tuple{VW, Dubins.DubinsPath}, Tuple{VW, Dubins.DubinsPath, Any}} where {W<:GatekeeperFormationFlight.AbstractWez, VW<:AbstractVector{W}}","page":"API","title":"GatekeeperFormationFlight.is_colliding","text":"is_colliding(wezes::Vector{AbstractWez}, path::DubinsPath, tol=1e-5)\n\nreturns true if the dubins path gets within tol distance of any wez. See docs for is_colliding(wez, path, tol). Sorts the wezes by distance before checking each one. \n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.is_colliding-Union{Tuple{W}, Tuple{W, Dubins.DubinsPath}, Tuple{W, Dubins.DubinsPath, Any}} where W<:GatekeeperFormationFlight.AbstractWez","page":"API","title":"GatekeeperFormationFlight.is_colliding","text":"is_colliding(wez::AbstractWez, path::DubinsPath, tol=1e-5)\n\nreturns true if the dubins path gets within tol distance of the wez. \n\nChecks by sampling every point tol apart along the path. \n\nTo reduce computational cost, it checks bounding boxes first, and then also skips points too close to each other where there is no possibility of collision. \n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.minimum_distance","page":"API","title":"GatekeeperFormationFlight.minimum_distance","text":"minimum_distance(c::AbstractWez p::SVector{2})\n\nutility function to get the smallest distance to a wez from the current location, indepednent of robot orientations. Currently only implemented for Cardioid and CircularWez.\n\n\n\n\n\n","category":"function"},{"location":"api/#GatekeeperFormationFlight.minimum_distance-Tuple{GatekeeperFormationFlight.CollisionRegion, GatekeeperFormationFlight.CollisionRegion}","page":"API","title":"GatekeeperFormationFlight.minimum_distance","text":"minimum_distance(reg1::CollisionRegion, reg2::CollisionRegion)\n\nreturn the minimum distance between reg1 and reg2\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.simulate_closed_loop_gatekeeper-Tuple{Any, Any, GatekeeperProblem}","page":"API","title":"GatekeeperFormationFlight.simulate_closed_loop_gatekeeper","text":"simulate_closed_loop_gatekeeper(initial_state, tspan, prob::GatekeeperProblem)\n\nreturns the closed-loop trajectory from running gatekeeper\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.total_path_length-Tuple{Dubins.DubinsPath}","page":"API","title":"GatekeeperFormationFlight.total_path_length","text":"total_path_length(path::DubinsPath)\n\nreturns the total path length of a dubins path\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.total_path_length-Tuple{Vector{Dubins.DubinsPath}}","page":"API","title":"GatekeeperFormationFlight.total_path_length","text":"total_path_length(path::Vector{DubinsPath})\n\nreturns the total path length of a vector of DubinPath\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.tracking_controller-Tuple{Any, Any, Any}","page":"API","title":"GatekeeperFormationFlight.tracking_controller","text":"tracking_controller(x, x_d, u_d; k1=450.0, k2=200.0, k3=50.0)\n\nreturns the [v, ω] to track a state x_d from current state x, given a feedforward term u_d. \n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.wez_coordinates","page":"API","title":"GatekeeperFormationFlight.wez_coordinates","text":"wez_coordinates(θ, wez::AbstractWez, robot::Robot)\n\nreturns the (x, y) coordinates of the wez boundary relative to a robot, parameterized by the polar angle θ ∈ [0, 2π]. \n\n\n\n\n\n","category":"function"},{"location":"api/#Private:","page":"API","title":"Private:","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GatekeeperFormationFlight]\nPublic = false","category":"page"},{"location":"api/#GatekeeperFormationFlight.Circle","page":"API","title":"GatekeeperFormationFlight.Circle","text":"Circle(center, radius)\n\ndefines a circluar region by center and radius.\n\n\n\n\n\n","category":"type"},{"location":"api/#GatekeeperFormationFlight.CompositeTrajectory","page":"API","title":"GatekeeperFormationFlight.CompositeTrajectory","text":"CompositeTrajectory(nominal_trajectory, backup_trajectory, switch_time)\n\ndefines a composite trajectory that includes a nominal trjectory, a backup trajectory, and a switch time\n\n\n\n\n\n","category":"type"},{"location":"api/#GatekeeperFormationFlight.LineSegment","page":"API","title":"GatekeeperFormationFlight.LineSegment","text":"LineSegment(p1, p2)\n\ndefines a line segment connecting points p1 and p2. Both p1 and p2 must be of type SVector{2, F}. \n\n\n\n\n\n","category":"type"},{"location":"api/#StaticArraysCore.SVector-Union{Tuple{Robot{F}}, Tuple{F}} where F","page":"API","title":"StaticArraysCore.SVector","text":"SVector(r::Robot)\n\nreturns a SVector{3, F} containing [x, y, ψ]\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.RRTStar.collision_free-Tuple{DubinsRRTProblem, Any, Any}","page":"API","title":"GatekeeperFormationFlight.RRTStar.collision_free","text":"collision_free(problem, x_nearest, x_new; step_size=0.001)\n\nchecks if a path from x_nearest to x_new is collision free with respect to the wezes in problem.wezes.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.RRTStar.near-Tuple{DubinsRRTProblem, Any, Any}","page":"API","title":"GatekeeperFormationFlight.RRTStar.near","text":"    near(problem, nodes, x_new)\n\nreturns the set of indices of nearby nodes to a state x_new. For simplicity, it currently just returns all nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.RRTStar.nearest-Tuple{DubinsRRTProblem, Any, Any}","page":"API","title":"GatekeeperFormationFlight.RRTStar.nearest","text":"nearest(problem, nodes, x_rand)\n\nreturns the index of the nearest node within the list of nodes to the state x_rand, according to a dubins path distance.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.RRTStar.path_cost-Tuple{DubinsRRTProblem, Any, Any}","page":"API","title":"GatekeeperFormationFlight.RRTStar.path_cost","text":"path_cost(problem, x_near, x_new)\n\nreturns the dubins path length from xnear to xnew.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.RRTStar.sample_free-Tuple{DubinsRRTProblem}","page":"API","title":"GatekeeperFormationFlight.RRTStar.sample_free","text":"sample_free(problem::DubinsRRTProblem)\n\nreturns a random state within the problem domain\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.RRTStar.steer-Tuple{DubinsRRTProblem, Any, Any}","page":"API","title":"GatekeeperFormationFlight.RRTStar.steer","text":"steer(problem, x_nearest, x_rand; max_travel_dist=0.2)\n\nreturns the state by travelling upto max_travel_dist towards x_rand starting from x_nearest.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.closed_loop_tracking_backup!-Tuple{Any, Any, Vector{Dubins.DubinsPath}, Any}","page":"API","title":"GatekeeperFormationFlight.closed_loop_tracking_backup!","text":"closed_loop_tracking_backup!(D, state, backup_path::Vector{DubinsPath}, backup_time)\n\ndefines the closed_loop dynamics for tracking the backup trajectory\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.closed_loop_tracking_composite!-NTuple{4, Any}","page":"API","title":"GatekeeperFormationFlight.closed_loop_tracking_composite!","text":"closed_loop_tracking_composite!(D, state, params, time)\n\ndefines the closed_loop dynamics for tracking a composite trajectory\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.closed_loop_tracking_nominal!-Tuple{Any, Any, GatekeeperProblem, Any}","page":"API","title":"GatekeeperFormationFlight.closed_loop_tracking_nominal!","text":"closed_loop_tracking_nominal!(D, state, prob::GatekeeperProblem, time)\n\ndefines the closed_loop dynamics for tracking the nominal trajectory\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.construct_candidate_backup_trajectory-Tuple{Any, GatekeeperProblem}","page":"API","title":"GatekeeperFormationFlight.construct_candidate_backup_trajectory","text":"construct_candidate_backup_trajectory(initial_state, prob::GatekeeperProblem)\n\nfrom some initial state, this function construsts the best backup trajectory\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.construct_candidate_nominal_trajectory-Tuple{Any, Any, GatekeeperProblem}","page":"API","title":"GatekeeperFormationFlight.construct_candidate_nominal_trajectory","text":"construct_candidate_nominal_trajectory(time, state, prob::GatekeeperProblem)\n\ndoes a closed-loop simulation of the nominal controller until either the time runs out or until it hits a wez\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.construct_reconnection_paths-Tuple{Any, Any, Any}","page":"API","title":"GatekeeperFormationFlight.construct_reconnection_paths","text":"construct_reconnection_paths(reconnection_sites, initial_state, turning_radius)\n\ngiven a list of reconnection sites, and the state from which we want to start, this function returns a list of dubins paths that connect to the reconnection sites. \n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.construct_reconnection_sites","page":"API","title":"GatekeeperFormationFlight.construct_reconnection_sites","text":"construct_reconnection_sites(reference_path::Vector{DubinsPath}, reconnection_step_size=0.01)\n\nalong a reference path, define the set of points where a trajectory can possibly reconnect. Returns a Vector{Tuple(Int64, SVector{3, Float64})}.  Each entry of this vector contains first the index of the reference path where the reconnection can happen, and second the state of reconnection. \n\n\n\n\n\n","category":"function"},{"location":"api/#GatekeeperFormationFlight.create_collision_region-Tuple{Cardioid}","page":"API","title":"GatekeeperFormationFlight.create_collision_region","text":"create_collision_region(c <: AbstractWez)\n\ngiven a wez, create a maximum collision region around it.  Currently only implemented for Cardioid.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.create_collision_region-Tuple{Dubins.DubinsPath, Any}","page":"API","title":"GatekeeperFormationFlight.create_collision_region","text":"create_collision_region(path::DubinsPath, segment_id)\n\ncreates a collision region for the segment_id section of a dubins path, assuming it has a known segment type\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.dubins_distance","page":"API","title":"GatekeeperFormationFlight.dubins_distance","text":"dubins_distance(q1, q2, turning_radius=0.1)\n\nget the distance between two states, if connected by a dubins path\n\n\n\n\n\n","category":"function"},{"location":"api/#GatekeeperFormationFlight.get_ω_sign-Tuple{Dubins.DubinsPath, Any}","page":"API","title":"GatekeeperFormationFlight.get_ω_sign","text":"get_ω_sign(path::DubinsPath, index)\n\nget the sign of the ω for the index-th subpart of a DubinsPath\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.post_extrapolate-Tuple{Any, Any}","page":"API","title":"GatekeeperFormationFlight.post_extrapolate","text":"post_extrapolate(path, time)\n\nreturn the state, input for a reference path beyond the end of the path, assumes the robot moves with v=1.0, ω=0.0.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.pre_extrapolate-Tuple{Vector{Dubins.DubinsPath}, Any}","page":"API","title":"GatekeeperFormationFlight.pre_extrapolate","text":"pre_extrapolate(path, time)\n\nreturn the state, input for a reference path for negative time. Assumes the robot moves with v=1.0, ω=0.0.\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.terminate_condition-Tuple{Any, Any, Any}","page":"API","title":"GatekeeperFormationFlight.terminate_condition","text":"terminate_condition(state,time,integrator)\n\ncallback to terminate integration when there is a collision\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.update_committed_affect!-Tuple{Any}","page":"API","title":"GatekeeperFormationFlight.update_committed_affect!","text":"update_committed_affect!(integrator)\n\ncallback to recompute the committed trajectory. Will replace the integrator's parameter if a new committed trajectory is found\n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.wrapToPi-Tuple{Any}","page":"API","title":"GatekeeperFormationFlight.wrapToPi","text":"wrapToPi(θ)\n\nreturns θ wrapped to lie within (-π, π]\n\n\n\n\n\n","category":"method"},{"location":"api/#RRTStar","page":"API","title":"RRTStar","text":"","category":"section"},{"location":"api/#Public:-2","page":"API","title":"Public:","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GatekeeperFormationFlight.RRTStar]\nPrivate = false","category":"page"},{"location":"api/#GatekeeperFormationFlight.RRTStar.Node","page":"API","title":"GatekeeperFormationFlight.RRTStar.Node","text":"Node{T}(state::T, parent_index::Int64, incremental_cost::Float64)\n\nDefines a node in the RRT* Tree, with a defined state, parent_index, and the incremental_cost from the parent to the current node.  Since the nodes are stored in a vector, the root node should have a parent_index=0.\n\n\n\n\n\n","category":"type"},{"location":"api/#GatekeeperFormationFlight.RRTStar.get_best_path-Union{Tuple{P}, Tuple{T}, Tuple{P, Array{Node{T}, 1}, Any}} where {T, P<:GatekeeperFormationFlight.RRTStar.AbstractProblem{T}}","page":"API","title":"GatekeeperFormationFlight.RRTStar.get_best_path","text":"get_best_path(problem::AbstractProblem, nodes::Vector{Node{T}}, x_goal::T)\n\nreturns the (true, best_path) if a path to x_goal is found.  returns (false, nothing) if no path to x_goal is found. \n\nThe best path is a list of nodes from the root to a node on the tree. returns the states along the nodes. \n\n\n\n\n\n","category":"method"},{"location":"api/#GatekeeperFormationFlight.RRTStar.rrt_star-Tuple{Any, Any, Any}","page":"API","title":"GatekeeperFormationFlight.RRTStar.rrt_star","text":"rrt_star(problem::AbstractProblem, nodes::Vector{Node}, max_iters::Int64; do_rewire=true)\n\nAdds max_iters nodes to the RRT* star. Will modify the nodes vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private:-2","page":"API","title":"Private:","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GatekeeperFormationFlight.RRTStar]\nPublic = false","category":"page"},{"location":"api/#GatekeeperFormationFlight.RRTStar.cost-Union{Tuple{T}, Tuple{Int64, Array{Node{T}, 1}}} where T","page":"API","title":"GatekeeperFormationFlight.RRTStar.cost","text":"cost(i::Int64, nodes::Vector{Node})\n\nreturns the cost to get to node i. Computes this quantity recursively. \n\n\n\n\n\n","category":"method"},{"location":"gatekeeper/#Gatekeeper","page":"Gatekeeper","title":"Gatekeeper","text":"","category":"section"},{"location":"gatekeeper/#Example","page":"Gatekeeper","title":"Example","text":"","category":"section"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"Consider the same environment as in the tracking controllers page.","category":"page"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"using GatekeeperFormationFlight\nusing Plots, LinearAlgebra, StaticArrays, Random\nusing Dubins\n\nGFF = GatekeeperFormationFlight\n\n# create an environment\nfunction create_random_scenario(N_wezes=24)\n    wezes_1 = [Cardioid(rand(), rand()) for i=1:N_wezes/2]\n    wezes_2 = [Cardioid(0.5 + 0.2 * randn(), 0.5 + 0.2 * randn()) for i=1:N_wezes/2]\n    wezes = vcat(wezes_1, wezes_2)\n    return wezes\nend\nRandom.seed!(27182818)\nwezes = create_random_scenario(24)\n\n# create a set of robots\nleader_robot = Robot(-0.25,0.,0.)\nfollower_robots = [\n    Robot(-0.3, -0.05, 0.0), \n    Robot(-0.3, 0.05, 0.0), \n    ]\nrobots = vcat(leader_robot, follower_robots...)\n\n# plan a path for the leader using RRT*\ndomain = (\n    (@SVector [0, 0, -1.0*π]),\n    (@SVector [1, 1,  1.0*π])\n)\nturning_radius = 0.1\nrrt_problem = DubinsRRTProblem(domain, turning_radius, wezes)\n\n# start the tree with the root node\nnodes = [Node(SVector(0,0,0.)), ]\n\n# add 1000 nodes to the tree\nnodes = rrt_star(rrt_problem, nodes, 1000)\n\n# see if there is a path \nsuccess_code, waypoints = get_best_path(rrt_problem, nodes, @SVector [1.0, 1.0, 0])\n\n# uncomment the following code if you want to add more nodes to the RRT* problem:\n## while we havent found a path, add some nodes and check if we have a feasible path\n## iter_counter = 0\n## while !success_code  && iter_counter < 10\n##     nodes = rrt_star(rrt_problem, nodes, 500)\n##     success_code, waypoints = get_best_path(rrt_problem, nodes, [1.0, 1.0, 0])\n##     iter_counter += 1\n## end\n        \n@assert success_code\n\n# prepend and append the start and the goal\nwaypoints = [\n    SVector(leader_robot), \n    waypoints..., \n    SVector(1.25,1,0.)\n]\n\npath = DubinsPath[]\n# add all the waypoints to the path\nfor i=2:length(waypoints)\n    e, p = dubins_shortest_path(waypoints[i-1], waypoints[i], rrt_problem.turning_radius)\n    @assert e == Dubins.EDUBOK\n    push!(path, p)\nend\n\n# small function to help plot things\nfunction plot_scenario!(wezes::VW, robots::VR; draw_bbox=true, title=nothing, kwargs...) where {W <: GFF.AbstractWez, VW <: AbstractVector{W}, R <: Robot, VR <: AbstractVector{R}}\n\n    if draw_bbox\n        # plot the bounding box\n        plot!([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], label = false, color = :black)\n        plot!(xlims = (-0.4, 1.4), ylims = (-0.1, 1.1))\n    end\n\n    # plot the wezes\n    for wez in wezes, robot in robots\n        plot!(wez, robot)\n    end\n\n    # plot the robot\n    for robot in robots\n        color = is_colliding(wezes, robot) ? :red : :green\n        plot!(robot; color = color)\n    end\n\n    if isnothing(title)\n        # get the minimum collision distance\n        mind = Inf\n        for r in robots, w in wezes\n            d = collision_distance(w, r)\n            mind = min(mind, d)\n        end\n        plot!(title = \"Min Wez Distance: $(round(mind; digits=2))\")\n\n        if mind <= 0\n            plot!(titlefont = font(:red))\n        else\n            plot!(titlefont = font(:black))\n        end\n    else\n        plot!(title = title)\n    end\n\n    plot!()\n\nend\n\nplot()\nplot_scenario!(wezes, robots)\nplot!(path, color=:black, label=false, linewidth=2)\ntitle!(\"best path\")\nplot!()","category":"page"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"plot!()","category":"page"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"Now we can construct a GatekeeperProblem:","category":"page"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"\noffsets = [SVector(robot) - SVector(leader_robot) for robot in robots]\n\nprob = GatekeeperProblem(;\n        wezes=wezes, \n        reference_path=path,\n        offset=offsets[1], \n        switch_step_size=2e-3, \n        reconnection_step_size=0.01, \n        max_Ts_horizon=0.5, \n        integration_max_step_size=1e-3, \n        collision_check_step_size=1e-3, \n        ) ","category":"page"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"For all three robots, we can define the set of problems as ","category":"page"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"gk_problems = [\n    GatekeeperProblem(;\n        wezes=wezes, \n        reference_path=path, offset=offsets[i], \n        switch_step_size=2e-3, \n        reconnection_step_size=0.01, \n        max_Ts_horizon=0.5, \n        integration_max_step_size=1e-3,\n        collision_check_step_size=1e-3,\n        ) \n    for i=1:length(robots)\n]","category":"page"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"We can now solve the problems and plot the solutions:","category":"page"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"tspan = [0.0, total_path_length(path)]\ngk_solutions = [\n    simulate_closed_loop_gatekeeper(\n        SVector(robots[i]), \n        tspan, \n        gk_problems[i])\n    for i=1:length(robots)\n]\n\nTmax = total_path_length(path)\n\n# plot reference path\nplot()\nplot_scenario!(wezes, robots)\n# for p in path\n#     plot!(p, color=:black, linestyle=:dash, label=false)\n# end\n\n# plot offset path\nfor i=1:length(robots)\n    plot!(τ-> get_reference_state_and_input(path, τ, offsets[i])[1][1], \n    τ-> get_reference_state_and_input(path, τ, offsets[i])[1][2],\n    0.0, Tmax, linestyle=:dash, label=false, linecolor=:black)\nend\n\n# plot the gk solution\nfor i=1:length(robots)\n    plot!(t->gk_solutions[i](t)[1], t->gk_solutions[i](t)[2], 0.0, Tmax, label=\"gk_sol_$(i)\", color=(i==1 ? :black : :green), linewidth=2)\nend\n\nplot!(aspect_ratio=:equal)","category":"page"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"Finally, lets animate the solutions:","category":"page"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"\n@gif for t in range(0, Tmax, length=120)\n\n    # grab the states\n    robots_ = [Robot(gk_solutions[i](t)) for i=1:length(gk_solutions)]\n\n    # start the plot\n    plot()\n\n    # plot the reference paths\n    for i=1:3\n        plot!(τ -> get_reference_state_and_input(path, τ, offsets[i])[1][1], τ -> get_reference_state_and_input(path, τ, offsets[i])[1][2], 0, Tmax;\n            label=false, color=:gray, linestyle=:dash)\n    end\n\n    # plot the trace of the robots upto this point of time\n    for i=1:3\n        plot!(τ -> gk_solutions[i](τ)[1], τ -> gk_solutions[i](τ)[2], 0.0, t, label=\"gk_sol_$(i)\", color=(i==1 ? :black : :green), linewidth=2)\n    end\n\n    # plot the current state of affairs\n    plot_scenario!(wezes, robots_)\n    \n    plot!()\nend","category":"page"},{"location":"gatekeeper/#Docs","page":"Gatekeeper","title":"Docs","text":"","category":"section"},{"location":"gatekeeper/#Public:","page":"Gatekeeper","title":"Public:","text":"","category":"section"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"Modules = [GatekeeperFormationFlight]\nPages = [\"gatekeeper.jl\"]\nPrivate = false","category":"page"},{"location":"gatekeeper/#GatekeeperFormationFlight.GatekeeperProblem-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.GatekeeperProblem","text":"GatekeeperProblem(kwargs...)\n\nconstruct a GatekeeperProblem. The arguments are:\n\nwezes,                              # list of wezes\nreference_path,                     # path of the leader\noffset = SVector(0.0, 0.0, 0.0),    # desired offset from the leaders path\nturning_radius = 0.1,               # max turning radius of a robot\nmaxTshorizon = 1.0,               # maximum switching time\nreconnectionstepsize = 0.1,       # resolution used for checking reconnection point\ncollisioncheckstep_size = 0.01,   # resolution used for checking collision along a path\nintegrationmaxstep_size = 0.05,   # max integration step size in nominal tracking\nswitchstepsize = 0.05             # resolution used to decrease switch time\n\n\n\n\n\n","category":"type"},{"location":"gatekeeper/#GatekeeperFormationFlight.construct_candidate_trajectory-Tuple{Any, Any, GatekeeperProblem}-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.construct_candidate_trajectory","text":"construct_candidate_trajectory(time, state, prob::GatekeeperProblem)\n\nconstructs a nominal trajectory, and working backwards tries to construct backup trajectories.  If a safe trajectory is found, this is returned as the candidate trajectory.  if not, nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"gatekeeper/#GatekeeperFormationFlight.simulate_closed_loop_gatekeeper-Tuple{Any, Any, GatekeeperProblem}-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.simulate_closed_loop_gatekeeper","text":"simulate_closed_loop_gatekeeper(initial_state, tspan, prob::GatekeeperProblem)\n\nreturns the closed-loop trajectory from running gatekeeper\n\n\n\n\n\n","category":"method"},{"location":"gatekeeper/#Private:","page":"Gatekeeper","title":"Private:","text":"","category":"section"},{"location":"gatekeeper/","page":"Gatekeeper","title":"Gatekeeper","text":"Modules = [GatekeeperFormationFlight]\nPages = [\"gatekeeper.jl\"]\nPublic = false","category":"page"},{"location":"gatekeeper/#GatekeeperFormationFlight.CompositeTrajectory-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.CompositeTrajectory","text":"CompositeTrajectory(nominal_trajectory, backup_trajectory, switch_time)\n\ndefines a composite trajectory that includes a nominal trjectory, a backup trajectory, and a switch time\n\n\n\n\n\n","category":"type"},{"location":"gatekeeper/#GatekeeperFormationFlight.closed_loop_tracking_backup!-Tuple{Any, Any, Vector{Dubins.DubinsPath}, Any}-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.closed_loop_tracking_backup!","text":"closed_loop_tracking_backup!(D, state, backup_path::Vector{DubinsPath}, backup_time)\n\ndefines the closed_loop dynamics for tracking the backup trajectory\n\n\n\n\n\n","category":"method"},{"location":"gatekeeper/#GatekeeperFormationFlight.closed_loop_tracking_composite!-NTuple{4, Any}-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.closed_loop_tracking_composite!","text":"closed_loop_tracking_composite!(D, state, params, time)\n\ndefines the closed_loop dynamics for tracking a composite trajectory\n\n\n\n\n\n","category":"method"},{"location":"gatekeeper/#GatekeeperFormationFlight.closed_loop_tracking_nominal!-Tuple{Any, Any, GatekeeperProblem, Any}-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.closed_loop_tracking_nominal!","text":"closed_loop_tracking_nominal!(D, state, prob::GatekeeperProblem, time)\n\ndefines the closed_loop dynamics for tracking the nominal trajectory\n\n\n\n\n\n","category":"method"},{"location":"gatekeeper/#GatekeeperFormationFlight.construct_candidate_backup_trajectory-Tuple{Any, GatekeeperProblem}-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.construct_candidate_backup_trajectory","text":"construct_candidate_backup_trajectory(initial_state, prob::GatekeeperProblem)\n\nfrom some initial state, this function construsts the best backup trajectory\n\n\n\n\n\n","category":"method"},{"location":"gatekeeper/#GatekeeperFormationFlight.construct_candidate_nominal_trajectory-Tuple{Any, Any, GatekeeperProblem}-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.construct_candidate_nominal_trajectory","text":"construct_candidate_nominal_trajectory(time, state, prob::GatekeeperProblem)\n\ndoes a closed-loop simulation of the nominal controller until either the time runs out or until it hits a wez\n\n\n\n\n\n","category":"method"},{"location":"gatekeeper/#GatekeeperFormationFlight.construct_reconnection_paths-Tuple{Any, Any, Any}-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.construct_reconnection_paths","text":"construct_reconnection_paths(reconnection_sites, initial_state, turning_radius)\n\ngiven a list of reconnection sites, and the state from which we want to start, this function returns a list of dubins paths that connect to the reconnection sites. \n\n\n\n\n\n","category":"method"},{"location":"gatekeeper/#GatekeeperFormationFlight.construct_reconnection_sites-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.construct_reconnection_sites","text":"construct_reconnection_sites(reference_path::Vector{DubinsPath}, reconnection_step_size=0.01)\n\nalong a reference path, define the set of points where a trajectory can possibly reconnect. Returns a Vector{Tuple(Int64, SVector{3, Float64})}.  Each entry of this vector contains first the index of the reference path where the reconnection can happen, and second the state of reconnection. \n\n\n\n\n\n","category":"function"},{"location":"gatekeeper/#GatekeeperFormationFlight.terminate_condition-Tuple{Any, Any, Any}-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.terminate_condition","text":"terminate_condition(state,time,integrator)\n\ncallback to terminate integration when there is a collision\n\n\n\n\n\n","category":"method"},{"location":"gatekeeper/#GatekeeperFormationFlight.update_committed_affect!-Tuple{Any}-gatekeeper","page":"Gatekeeper","title":"GatekeeperFormationFlight.update_committed_affect!","text":"update_committed_affect!(integrator)\n\ncallback to recompute the committed trajectory. Will replace the integrator's parameter if a new committed trajectory is found\n\n\n\n\n\n","category":"method"},{"location":"robots_and_wezes/#Robots-and-Wezes","page":"Robots and Wezes","title":"Robots and Wezes","text":"","category":"section"},{"location":"robots_and_wezes/#Tutorial","page":"Robots and Wezes","title":"Tutorial","text":"","category":"section"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"To construct a robot use","category":"page"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"robot = Robot(x, y, psi)","category":"page"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"To construct a wez, use one of","category":"page"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"wez = Cardioid(x, y)\nwez = CircularWez(x, y)\nwez = Cbez(x, y, ψ)","category":"page"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"each of these wezes is a subtype of AbstractWez. See the docs below to customize each wez.","category":"page"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"To check collision between a robot and a wez, use","category":"page"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"is_colliding(wez, robot)","category":"page"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"you can also get the collision_distance(wez, robot) or the wez_coordinates(theta, wez, robot). ","category":"page"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"To plot the robot or the wezes, simply","category":"page"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"using Plots\n\nplot()\nplot!(wez)\nplot!(robot)","category":"page"},{"location":"robots_and_wezes/#Example","page":"Robots and Wezes","title":"Example","text":"","category":"section"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"using GatekeeperFormationFlight\nusing Plots, LinearAlgebra, StaticArrays, Random\n\nGFF = GatekeeperFormationFlight\n\n# function to create an environment\nfunction create_random_scenario(N_wezes=24)\n    wezes_1 = [Cardioid(rand(), rand()) for i=1:N_wezes/2]\n    wezes_2 = [Cardioid(0.5 + 0.2 * randn(), 0.5 + 0.2 * randn()) for i=1:N_wezes/2]\n    wezes = vcat(wezes_1, wezes_2)\n    return wezes\nend\n\n# create the environment\nRandom.seed!(27182818)\nwezes = create_random_scenario(24)\n\n# create a set of robots\nleader_robot = Robot(-0.25,0.,0.)\nfollower_robots = [\n    Robot(-0.3, -0.05, 0.0), \n    Robot(-0.3, 0.05, 0.0), \n    ]\nrobots = vcat(leader_robot, follower_robots...)\n\n# small function to help plot things\nfunction plot_scenario!(wezes::VW, robots::VR; draw_bbox=true, title=nothing, kwargs...) where {W <: GFF.AbstractWez, VW <: AbstractVector{W}, R <: Robot, VR <: AbstractVector{R}}\n\n    if draw_bbox\n        # plot the bounding box\n        plot!([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], label = false, color = :black)\n        plot!(xlims = (-0.4, 1.4), ylims = (-0.1, 1.1))\n    end\n\n    # plot the wezes\n    for wez in wezes, robot in robots\n        plot!(wez, robot)\n    end\n\n    # plot the robot\n    for robot in robots\n        color = is_colliding(wezes, robot) ? :red : :green\n        plot!(robot; color = color)\n    end\n\n    if isnothing(title)\n        # get the minimum collision distance\n        mind = Inf\n        for r in robots, w in wezes\n            d = collision_distance(w, r)\n            mind = min(mind, d)\n        end\n        plot!(title = \"Min Wez Distance: $(round(mind; digits=2))\")\n\n        if mind <= 0\n            plot!(titlefont = font(:red))\n        else\n            plot!(titlefont = font(:black))\n        end\n    else\n        plot!(title = title)\n    end\n\n    plot!()\n\nend\n\n# plot everything\nplot()\nplot_scenario!(wezes, robots)","category":"page"},{"location":"robots_and_wezes/#Docs","page":"Robots and Wezes","title":"Docs","text":"","category":"section"},{"location":"robots_and_wezes/#Public","page":"Robots and Wezes","title":"Public","text":"","category":"section"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"Modules = [GatekeeperFormationFlight]\nPages = [\"robot.jl\", \"wez.jl\", \"plotting_utils.jl\"]\nPrivate = false","category":"page"},{"location":"robots_and_wezes/#GatekeeperFormationFlight.Robot-robots_and_wezes","page":"Robots and Wezes","title":"GatekeeperFormationFlight.Robot","text":"Robot(x, y, ψ)\nRobot([x, y, ψ])\n\nCreate a robot with some x, y position and heading ψ.\n\n\n\n\n\n","category":"type"},{"location":"robots_and_wezes/#GatekeeperFormationFlight.Cardioid-robots_and_wezes","page":"Robots and Wezes","title":"GatekeeperFormationFlight.Cardioid","text":"Cardioid(x, y, Rmin=0.0, Rmax=0.15)\n\nConstruct a Cardioid WEZ at position x, y with radii Rmin, and Rmax.\n\n\n\n\n\n","category":"type"},{"location":"robots_and_wezes/#GatekeeperFormationFlight.Cbez-robots_and_wezes","page":"Robots and Wezes","title":"GatekeeperFormationFlight.Cbez","text":"Cbez(x, y, ψ)\nCbez(x, y, ψ, μ=0.9, ā=0.25, v=1.0, R=π/2, t=π/2)\n\nDefine a Curve-Only Basic WEZ at some x, y with a heading ψ. \n\n\n\n\n\n","category":"type"},{"location":"robots_and_wezes/#GatekeeperFormationFlight.CircularWez-robots_and_wezes","page":"Robots and Wezes","title":"GatekeeperFormationFlight.CircularWez","text":"CircularWez(x, y, R=0.15)\n\nDefine a Circluar WEZ at some x, y with radius R.\n\n\n\n\n\n","category":"type"},{"location":"robots_and_wezes/#GatekeeperFormationFlight.collision_distance-robots_and_wezes","page":"Robots and Wezes","title":"GatekeeperFormationFlight.collision_distance","text":"collision_distance(wez::AbstractWez, robot::Robot)\ncollision_distance(wezez::Vector{AbstractWez}, robot::Robot)\n\nreturns the distance to collision for this robot to the wez. Positive if safe. If the robot is within the wez, it will return a negative number. \n\n\n\n\n\n","category":"function"},{"location":"robots_and_wezes/#GatekeeperFormationFlight.is_colliding-robots_and_wezes-2","page":"Robots and Wezes","title":"GatekeeperFormationFlight.is_colliding","text":"is_colliding(wez::AbstractWez, robot::Robot, tol)\nis_colliding(wezes::Vector{AbstractWez}, robot::Robot, tol)\n\nreturns collision_distance(wez, robot) <= tol\n\n\n\n\n\n","category":"function"},{"location":"robots_and_wezes/#GatekeeperFormationFlight.minimum_distance-robots_and_wezes","page":"Robots and Wezes","title":"GatekeeperFormationFlight.minimum_distance","text":"minimum_distance(c::AbstractWez p::SVector{2})\n\nutility function to get the smallest distance to a wez from the current location, indepednent of robot orientations. Currently only implemented for Cardioid and CircularWez.\n\n\n\n\n\n","category":"function"},{"location":"robots_and_wezes/#GatekeeperFormationFlight.wez_coordinates-robots_and_wezes","page":"Robots and Wezes","title":"GatekeeperFormationFlight.wez_coordinates","text":"wez_coordinates(θ, wez::AbstractWez, robot::Robot)\n\nreturns the (x, y) coordinates of the wez boundary relative to a robot, parameterized by the polar angle θ ∈ [0, 2π]. \n\n\n\n\n\n","category":"function"},{"location":"robots_and_wezes/#Private","page":"Robots and Wezes","title":"Private","text":"","category":"section"},{"location":"robots_and_wezes/","page":"Robots and Wezes","title":"Robots and Wezes","text":"Modules = [GatekeeperFormationFlight]\nPages = [\"robot.jl\", \"wez.jl\", \"plotting_utils.jl\"]\nPublic = false","category":"page"},{"location":"robots_and_wezes/#StaticArraysCore.SVector-Union{Tuple{Robot{F}}, Tuple{F}} where F-robots_and_wezes","page":"Robots and Wezes","title":"StaticArraysCore.SVector","text":"SVector(r::Robot)\n\nreturns a SVector{3, F} containing [x, y, ψ]\n\n\n\n\n\n","category":"method"},{"location":"rrt_star/#RRT*","page":"RRT*","title":"RRT*","text":"","category":"section"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"We use RRT* as an offline method to solve for the path through an environment with wezes.","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"Note, we are using Dev's fork of Dubins.jl, available at http://github.com/dev10110/Dubins.jl","category":"page"},{"location":"rrt_star/#Example:","page":"RRT*","title":"Example:","text":"","category":"section"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"First define the environment, as in the previous page.","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"using GatekeeperFormationFlight\nusing Plots, LinearAlgebra, StaticArrays, Random\nusing Dubins\n\nGFF = GatekeeperFormationFlight\n\n# create an environment\nfunction create_random_scenario(N_wezes=24)\n    wezes_1 = [Cardioid(rand(), rand()) for i=1:N_wezes/2]\n    wezes_2 = [Cardioid(0.5 + 0.2 * randn(), 0.5 + 0.2 * randn()) for i=1:N_wezes/2]\n    wezes = vcat(wezes_1, wezes_2)\n    return wezes\nend\nRandom.seed!(27182818)\nwezes = create_random_scenario(24)\n\n# create a set of robots\nleader_robot = Robot(-0.25,0.,0.)\nfollower_robots = [\n    Robot(-0.3, -0.05, 0.0), \n    Robot(-0.3, 0.05, 0.0), \n    ]\nrobots = vcat(leader_robot, follower_robots...)\n\n# small function to help plot things\nfunction plot_scenario!(wezes::VW, robots::VR; draw_bbox=true, title=nothing, kwargs...) where {W <: GFF.AbstractWez, VW <: AbstractVector{W}, R <: Robot, VR <: AbstractVector{R}}\n\n    if draw_bbox\n        # plot the bounding box\n        plot!([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], label = false, color = :black)\n        plot!(xlims = (-0.4, 1.4), ylims = (-0.1, 1.1))\n    end\n\n    # plot the wezes\n    for wez in wezes, robot in robots\n        plot!(wez, robot)\n    end\n\n    # plot the robot\n    for robot in robots\n        color = is_colliding(wezes, robot) ? :red : :green\n        plot!(robot; color = color)\n    end\n\n    if isnothing(title)\n        # get the minimum collision distance\n        mind = Inf\n        for r in robots, w in wezes\n            d = collision_distance(w, r)\n            mind = min(mind, d)\n        end\n        plot!(title = \"Min Wez Distance: $(round(mind; digits=2))\")\n\n        if mind <= 0\n            plot!(titlefont = font(:red))\n        else\n            plot!(titlefont = font(:black))\n        end\n    else\n        plot!(title = title)\n    end\n\n    plot!()\n\nend\n\n# plot everything\nplot()\nplot_scenario!(wezes, robots)","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"# plot everything\nplot()\nplot_scenario!(wezes, robots)","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"Define and solve the RRT* problem:","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"\n# plan a path for the leader using RRT*\ndomain = (\n    (@SVector [0, 0, -1.0*π]),\n    (@SVector [1, 1,  1.0*π])\n)\nturning_radius = 0.1\nrrt_problem = DubinsRRTProblem(domain, turning_radius, wezes)\n\n# start the tree with the root node\nnodes = [Node(SVector(0,0,0.)), ]\n\n# add 1000 nodes to the tree\nnodes = rrt_star(rrt_problem, nodes, 1000)\n\n# see if there is a path \nsuccess_code, waypoints = get_best_path(rrt_problem, nodes, @SVector [1.0, 1.0, 0])\n\n# uncomment the following code if you want to add more nodes to the RRT* problem:\n## while we havent found a path, add some nodes and check if we have a feasible path\n## iter_counter = 0\n## while !success_code  && iter_counter < 10\n##     nodes = rrt_star(rrt_problem, nodes, 500)\n##     success_code, waypoints = get_best_path(rrt_problem, nodes, [1.0, 1.0, 0])\n##     iter_counter += 1\n## end\n        \n@assert success_code\n\n# prepend and append the start and the goal\nwaypoints = [\n    SVector(leader_robot), \n    waypoints..., \n    SVector(1.25,1,0.)\n]","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"Now we have a list of waypoints, construct a path through them","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"path = DubinsPath[]\n# add all the waypoints to the path\nfor i=2:length(waypoints)\n    e, p = dubins_shortest_path(waypoints[i-1], waypoints[i], rrt_problem.turning_radius)\n    @assert e == Dubins.EDUBOK\n    push!(path, p)\nend\npath","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"path is now of type Vector{DubinsPath}. Plot it:","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"plot()\nplot_scenario!(wezes, robots)\nplot!(path, color=:black, label=false, linewidth=2)\ntitle!(\"best path\")\nplot!()","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"Notice we have provided a function to call plot! on DubinsPath or on Vector{DubinsPath}. ","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"We can also animate the trajectory ","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"\n@gif for t in range(0, total_path_length(path), length=120)\n\n    leader_state, leader_input = get_reference_state_and_input(path, t)\n\n    leader = Robot(leader_state)\n\n    plot()\n    plot_scenario!(wezes, [leader])\nend","category":"page"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"get_reference_state_and_input is explained on the next page.","category":"page"},{"location":"rrt_star/#Docs","page":"RRT*","title":"Docs","text":"","category":"section"},{"location":"rrt_star/#Public","page":"RRT*","title":"Public","text":"","category":"section"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"Modules=[GatekeeperFormationFlight]\nPages = [\"dubins_rrt_star.jl\"]\nPrivate = false","category":"page"},{"location":"rrt_star/#GatekeeperFormationFlight.DubinsRRTProblem-rrt_star","page":"RRT*","title":"GatekeeperFormationFlight.DubinsRRTProblem","text":"DubinsRRTProblem(domain, turning_radius, wezes)\n\nConstruct a dubins RRT* problem. \n\nParameters:\n\ndomain: a tuple defining the domain\nturning_radius: turning radius for Dubins paths\nwezes: A vector of wezes to avoid\n\nExample:\n\nusing GatekeeperFormationFlight\nusing StaticArrays\n\nmin_domain = SVector{3}(0.0, 0.0, -1.0*π)\nmax_domain = SVector{3}(1.0, 1.0, 1.0*π)\ndomain = (min_domain, max_domain)\n\nturning_radius = 0.1\n\nwezes = [Cardioid(rand(), rand()) for i=1:10]\n\nrrt_problem = DubinsRRTProblem(domain, turning_radius, wezes)\n\n\n\n\n\n","category":"type"},{"location":"rrt_star/#Private","page":"RRT*","title":"Private","text":"","category":"section"},{"location":"rrt_star/","page":"RRT*","title":"RRT*","text":"Modules=[GatekeeperFormationFlight]\nPages = [\"dubins_rrt_star.jl\"]\nPublic = false","category":"page"},{"location":"rrt_star/#GatekeeperFormationFlight.RRTStar.collision_free-Tuple{DubinsRRTProblem, Any, Any}-rrt_star","page":"RRT*","title":"GatekeeperFormationFlight.RRTStar.collision_free","text":"collision_free(problem, x_nearest, x_new; step_size=0.001)\n\nchecks if a path from x_nearest to x_new is collision free with respect to the wezes in problem.wezes.\n\n\n\n\n\n","category":"method"},{"location":"rrt_star/#GatekeeperFormationFlight.RRTStar.near-Tuple{DubinsRRTProblem, Any, Any}-rrt_star","page":"RRT*","title":"GatekeeperFormationFlight.RRTStar.near","text":"    near(problem, nodes, x_new)\n\nreturns the set of indices of nearby nodes to a state x_new. For simplicity, it currently just returns all nodes.\n\n\n\n\n\n","category":"method"},{"location":"rrt_star/#GatekeeperFormationFlight.RRTStar.nearest-Tuple{DubinsRRTProblem, Any, Any}-rrt_star","page":"RRT*","title":"GatekeeperFormationFlight.RRTStar.nearest","text":"nearest(problem, nodes, x_rand)\n\nreturns the index of the nearest node within the list of nodes to the state x_rand, according to a dubins path distance.\n\n\n\n\n\n","category":"method"},{"location":"rrt_star/#GatekeeperFormationFlight.RRTStar.path_cost-Tuple{DubinsRRTProblem, Any, Any}-rrt_star","page":"RRT*","title":"GatekeeperFormationFlight.RRTStar.path_cost","text":"path_cost(problem, x_near, x_new)\n\nreturns the dubins path length from xnear to xnew.\n\n\n\n\n\n","category":"method"},{"location":"rrt_star/#GatekeeperFormationFlight.RRTStar.sample_free-Tuple{DubinsRRTProblem}-rrt_star","page":"RRT*","title":"GatekeeperFormationFlight.RRTStar.sample_free","text":"sample_free(problem::DubinsRRTProblem)\n\nreturns a random state within the problem domain\n\n\n\n\n\n","category":"method"},{"location":"rrt_star/#GatekeeperFormationFlight.RRTStar.steer-Tuple{DubinsRRTProblem, Any, Any}-rrt_star","page":"RRT*","title":"GatekeeperFormationFlight.RRTStar.steer","text":"steer(problem, x_nearest, x_rand; max_travel_dist=0.2)\n\nreturns the state by travelling upto max_travel_dist towards x_rand starting from x_nearest.\n\n\n\n\n\n","category":"method"},{"location":"rrt_star/#GatekeeperFormationFlight.dubins_distance-rrt_star","page":"RRT*","title":"GatekeeperFormationFlight.dubins_distance","text":"dubins_distance(q1, q2, turning_radius=0.1)\n\nget the distance between two states, if connected by a dubins path\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GatekeeperFormationFlight","category":"page"},{"location":"#GatekeeperFormationFlight","page":"Home","title":"GatekeeperFormationFlight","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GatekeeperFormationFlight.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First, clone this repo to a desired location. cd into that directory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Run the tests","category":"page"},{"location":"","page":"Home","title":"Home","text":"] test","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have issues with Dubins.jl, install Dev's fork of Dubins.jl :","category":"page"},{"location":"","page":"Home","title":"Home","text":"] rm Dubins\n] add http://github.com/dev10110/Dubins.jl","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From the examples directory, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project full_example.md","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To build the documentation, cd into the docs directory, and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project make.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"In a separate terminal (from the docs directory), start the liveserver:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia -e 'using LiveServer; serve(dir=\"build\")'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now go to localhost:8000 and you should see the docs. ","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
